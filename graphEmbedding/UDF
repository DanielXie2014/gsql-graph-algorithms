
  // random function, generate a random value between 0 and 1
  inline float random(){
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0, 1);
    return dis(gen);
  }

  // generate a int random value given a range
  inline int random_range(int start, int end){
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(start, end);
    return dis(gen);

}
  // generate a random value based on probability distribution
  // For example: given {0.5,0.3,0.2}, this function will generate {0,1,2} based on its probability	
  inline int random_distribution(ListAccum<float> p){
    std::vector<float> a = p.data_;
    std::random_device rd;
    std::mt19937 gen(rd());
    std::discrete_distribution<> dis(a.begin(), a.end());
    return dis(gen);
}


 // node2vec function: given random walk sequence, this function trains vector using skip-gram model
 inline void node2vec(int dimension, string input_file, string output_file){
    Model model(dimension);
    model.sample_ = 0;
    // model.window = 10;
    int n_workers = 4;
    std::vector<SentenceP> sentences;

    size_t count =0;
    const size_t max_sentence_len = 200;

    SentenceP sentence(new Sentence);
    std::ifstream in(input_file);
    while (true) {
        std::string s;
        in >> s;
        if (s.empty()) break;
        ++count;
        sentence->tokens_.push_back(std::move(s));
        if (count == max_sentence_len) {
            count = 0;
            sentences.push_back(std::move(sentence));
            sentence.reset(new Sentence);
        }
    }

    if (!sentence->tokens_.empty())
        sentences.push_back(std::move(sentence));

    model.build_vocab(sentences);
    model.train(sentences, n_workers);
    model.save(output_file);

}
