CREATE QUERY tri_count_fast(INT split = 1) FOR GRAPH *graph* {
# Compute the total number of triangles in the graph
# This algorithm is faster than tri_count but uses additional memory for temporary storage
        SumAccum<int> @@cnt, @outdegree;
        SetAccum<int> @neighbors;
      
        all = {*vertex-types*};
	      all = SELECT s
	            FROM all:s
	            ACCUM s.@outdegree += *s_outdegrees*;
	      FOREACH i IN RANGE[0, split-1] DO 
                subset = SELECT s
                         FROM all:s
                         WHERE getvid(s) % split == i;
	              tmp = SELECT s
	                    FROM subset:s -(*edge-types*) -:t
	                    ACCUM IF s == t THEN 
	                            s.@outdegree += -1
	                    END;
	      END;
  
# We build up our neighbor lists manually because we'll only build them up on the 2 smaller vertices on a triangle. 
	      FOREACH i IN RANGE[0, split-1] DO 
                subset = SELECT s
                         FROM all:s
                         WHERE getvid(s) % split == i;
                tmp = SELECT t
                      FROM subset:s-(*edge-types*)-> :t
                      WHERE s.@outdegree > t.@outdegree OR (s.@outdegree == t.@outdegree AND getvid(s) > getvid(t))
                      ACCUM t.@neighbors += getvid(s);
	      END;
  
# Here we compute the intersection for 2 points on the triangle.
	      FOREACH i IN RANGE[0, split-1] DO 
                subset = SELECT s
                         FROM all:s
                         WHERE getvid(s) % split == i;
                tmp = SELECT t
                      FROM subset:s-(*edge-types*)-> :t
                      WHERE s != t
                      ACCUM @@cnt += COUNT(s.@neighbors INTERSECT t.@neighbors);
	      END;
	           
# Divide by 2 because every triangle was counted twice
        PRINT @@cnt/2 AS num_triangles;

}
