*ATTR*CREATE QUERY cycle_detection*EXT* () FOR GRAPH *graph* {
*ACCM*CREATE QUERY cycle_detection*EXT* () FOR GRAPH *graph* {
*FILE*CREATE QUERY cycle_detection*EXT* (FILE f) FOR GRAPH *graph* {
/* Rochaâ€“Thatte cycle detection algorithm
This is a distributed algorithm for detecting all the cycles on large-scale directed graphs.In every iteration, the vertices send its sequences to its out-neighbors, and receive the sequences from the in-neighbors.
Stop passing the sequence (v1,v2,v3, ...) when:
1. v = v1. If v has the minimum label in the sequence, report the cycle
2. v = vi (i!=1). Do not report since this cycle is already reported in an earlier iteration
*/
        TYPEDEF TUPLE <VERTEX personV, INT uid> p;
        ListAccum<ListAccum<p>> @currList, @newList, @@cycles;
*ATTR*  SetAccum<VERTEX> @@v_cycles;
        SumAccum<INT> @uid;
        
        Active = {*vertex-types*};
        Active = SELECT s 
                 FROM Active:s
                 ACCUM s.@uid = getvid(s)
                 POST-ACCUM s.@currList = [[p(s, s.@uid), p(s, s.@uid)]];  # use the first one in the list to store the minimal
        
        WHILE Active.size() > 0 DO 
                Active = SELECT t 
                         FROM Active:s -(*edge-types*:e)-> :t
                         ACCUM INT i = 0,
                               FOREACH l IN s.@currList DO 
                                       IF t == l.get(1).personV THEN # find cycle
                                               IF t == l.get(0).personV THEN  # if it is the mininal in the list, report 
*ATTR*                                                 FOREACH pair IN l DO
*ATTR*                                                         @@v_cycles += pair.personV
*ATTR*                                                 END
*ACCM*                                                 @@cycles += l 
*FILE*                                                 @@cycles += l
                                               END
                                       ELSE IF l.contains(p(t, t.@uid)) == FALSE THEN   # do not add into list if already had cycle
                                               t.@newList += [l + [p(t, t.@uid)]]   # update another list to avoid confliction
                                       END
                               END
                         POST-ACCUM FOREACH l IN t.@newList DO
                                            IF t.@uid < l.get(0).uid THEN
                                                    l.update(0, p(t, t.@uid))
                                            END
                                    END,
                                    s.@currList.clear(),
                                    t.@currList = t.@newList,
                                    t.@newList.clear()
                         HAVING t.@currList.size() > 0;  # IF receive no INFO, deactivate it;
        END;

*ATTR*  Active = {@@v_cycles};
*ATTR*  Active = SELECT s
*ATTR*           FROM Active:s
*ATTR*           POST-ACCUM s.*vBoolAttr* = true;
*ACCM*  PRINT @@cycles;   # the first node in each list can be ignored
*FILE*  FOREACH item IN @@cycles DO
*FILE*           f.println(item);   # the first node in each list can be ignored
*FILE*  END;
}






