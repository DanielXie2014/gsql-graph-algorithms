*SUB* CREATE QUERY knn_cosine_ss*EXT* (VERTEX source, INT topK) FOR GRAPH *graph* RETURNS (STRING) {
/* This subquery is k-nearest neighbors based on Cosine Similarity between a given vertex and every other vertex.
Cosine similarity = A \dot B / ||A|| \dot ||B||
*/
        SumAccum<FLOAT> @numerator, @@norm1, @norm2, @similarity;
        MapAccum<STRING, INT> @@count;
        INT maxCount = 0;
        STRING chosenLabel;

        # calculate similarity and find the top k nearest neighbors
        Start = {source};
        Subjects = SELECT t
                   FROM Start:s -(*edge-types*:e)-> :t
                   ACCUM t.@numerator = e.*edge-weight*,
                         @@norm1 += pow(e.*edge-weight*, 2);

        Neighbours = SELECT t
                     FROM Subjects:s -(*sec-edge-types*:e)-> *vertex-types*:t
                     WHERE t != source AND t.*vertex-label* != ""    # only consider the ones with known label
                     ACCUM t.@numerator += s.@numerator * e.*edge-weight*;

        kNN = SELECT s
              FROM Neighbours:s -(*edge-types*:e)-> :t
              ACCUM s.@norm2 += pow(e.*edge-weight*, 2)
              POST-ACCUM s.@similarity = s.@numerator/sqrt(@@norm1 * s.@norm2)
              ORDER BY s.@similarity DESC
              LIMIT topK;

        #predict label
        kNN = SELECT s
              FROM kNN:s
              ACCUM @@count += (s.*vertex-label* -> 1);

        FOREACH (label, cnt) IN @@count DO
            IF cnt > maxCount THEN
                maxCount = cnt;
                chosenLabel = label;
            END;
        END;

        PRINT chosenLabel;
        RETURN chosenLabel;

}

*ATTR*CREATE QUERY knn_cosine_all*EXT* (INT topK) FOR GRAPH *graph* {
*ACCM*CREATE QUERY knn_cosine_all*EXT* (INT topK) FOR GRAPH *graph* {
*FILE*CREATE QUERY knn_cosine_all*EXT* (INT topK, FILE f) FOR GRAPH *graph* {
/* This query is k-nearest neighbors based on Cosine Similarity on all vertices.
   The output is the predicted label for all the vertices depending on the majority label of their k-nearest neighbors.
*/
        SumAccum<STRING> @predicted_label;
        
        Source = {*vertex-types*.*};        
        Source = SELECT s
                 FROM Source:s 
                 WHERE s.*vertex-label* == ""
*ACCM*           ACCUM s.@predicted_label = knn_cosine_ss(s, topK);    
*ATTR*           POST-ACCUM s.*vStrAttr* = knn_cosine_ss(s, topK);
*FILE*           ACCUM s.@predicted_label = knn_cosine_ss(s, topK)
*FILE*           POST-ACCUM f.println(s, s.@predicted_label);
*ACCM*  PRINT Source;
  
}
