*ATTR*CREATE QUERY conn_comp2*EXT* () FOR GRAPH *graph* {
*ACCM*CREATE QUERY conn_comp2*EXT* () FOR GRAPH *graph* {
*FILE*CREATE QUERY conn_comp2*EXT* (FILE f) FOR GRAPH *graph* {
# This query identifies the Connected Components (undirected edges)

        SumAccum<INT> @cid;        //community id for each vertex
*ACCM*  MapAccum<INT, INT> @@compSizes;
        OrAccum @visited;
        INT n = 0;
        INT curr_cid;
        Unvisited = {Person.*};

# Initialize: Label each vertex with its own internal ID
        Unvisited = SELECT s
                    FROM Unvisited:s
                    POST-ACCUM s.@cid = getvid(s);

# Traverse from an unvisited vertex, and mark its connected vertices
        WHILE (Unvisited.size() > 0) DO
                Start = SELECT s
                        FROM Unvisited:s
                        LIMIT 1;
                Start = SELECT s
                        FROM Start:s
                        ACCUM s.@visited = true
*ACCM*                  POST-ACCUM curr_cid = s.@cid
                        ;
                WHILE (Start.size() > 0) DO
                        Unvisited = Unvisited MINUS Start;
*ACCM*                  @@compSizes += (curr_cid -> Start.size());
                        Start = SELECT t
                                FROM Start:s -(Coworker:e)-> Person:t
                                WHERE t.@visited == false
                                ACCUM t.@cid = s.@cid,
                                      t.@visited = true;
                END;
        END;

        Start = {*vertex-types*};
*ATTR*  Start = SELECT s FROM Start:s
*ATTR*          POST-ACCUM s.*vIntAttr* = s.@cid;

*ACCM*  Start = SELECT s FROM Start:s
*ACCM*          POST-ACCUM @@compSizes += (s.@cid -> 1);
*ACCM*  PRINT @@compSizes;
*ACCM*  PRINT Start.@cid;

*FILE*  f.println("Vertex_ID","Component_ID");
*FILE*  Start = SELECT s FROM Start:s
*FILE*        	POST-ACCUM f.println(s, s.@cid);
}

#INSTALL QUERY conn_comp*EXT*
