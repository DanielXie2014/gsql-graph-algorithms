*ATTR*CREATE QUERY cycle_detection*EXT* (INT depth) FOR GRAPH social {
*ACCM*CREATE QUERY cycle_detection*EXT* (INT depth) FOR GRAPH social {
*FILE*CREATE QUERY cycle_detection*EXT* (INT depth, FILE f) FOR GRAPH social {
/* Rochaâ€“Thatte cycle detection algorithm
This is a distributed algorithm for detecting all the cycles on large-scale directed graphs.In every iteration, the vertices send its sequences to its out-neighbors, and receive the sequences from the in-neighbors.
Stop passing the sequence (v1,v2,v3, ...) when:
1. v = v1. If v has the minimum label in the sequence, report the cycle
2. v = vi (i!=1). Do not report since this cycle is already reported in an earlier iteration
*/

        TYPEDEF TUPLE <VERTEX v, INT uid> p;
        ListAccum<ListAccum<p>> @currList, @newList;
*ACCM* ListAccum<ListAccum<p>> @@cycles;
*ATTR*  SetAccum<VERTEX> @@v_cycles;
        SumAccum<INT> @uid;
  
        # initialization
        Active = {Person.*};
        Active = SELECT s 
                 FROM Active:s
                 ACCUM s.@uid = getvid(s)
                 POST-ACCUM s.@currList = [[p(s, s.@uid)]];
  
        WHILE Active.size() > 0 LIMIT depth DO 
        Active = SELECT t 
                 FROM Active:s -(Friend:e)-> :t
                 ACCUM BOOL t_is_min = TRUE,
                       FOREACH sequence IN s.@currList DO 
                               IF t == sequence.get(0).v THEN  # cycle detected
                                        FOREACH item IN sequence DO
                                                IF item.uid < t.@uid THEN
                                                        t_is_min = FALSE,
                                                        BREAK
                                                END
                                        END,
                                        IF t_is_min == TRUE THEN  # if it has the minimal label in the list, report 
*ATTR*                                          FOREACH item IN sequence DO
*ATTR*                                                  @@v_cycles += item.v
*ATTR*                                          END
*ACCM*                                          @@cycles += sequence
*FILE*                                          f.println(sequence)
                                        END
                               ELSE IF sequence.contains(p(t, t.@uid)) == FALSE THEN   # discard the sequences contain t
                                        t.@newList += [sequence + [p(t, t.@uid)]]   # store sequences in @newList to avoid confliction with @currList
                               END
                       END
                 POST-ACCUM s.@currList.clear(),
                            t.@currList = t.@newList,
                            t.@newList.clear()
                 HAVING t.@currList.size() > 0;  # IF receive no sequences, deactivate it;
        END;
*ATTR*  Active = {@@v_cycles};
*ATTR*  Active = SELECT s
*ATTR*           FROM Active:s
*ATTR*           POST-ACCUM s.*vBoolAttr* = true;
*ACCM*  PRINT @@cycles;   
}

